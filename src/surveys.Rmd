---
title: "Analysing survey data"
author: "Paul Sharpe, Sophie Homer, Andy Wills"
output: html_document
---

```{r setup, include=FALSE}
## DEVELOPERS: Uncomment one option, as appropriate

## Show only commands.
## knitr::opts_chunk$set(echo = TRUE, message = FALSE, results='hide', fig.keep = 'none', comment=NA)

## Show commands and output.
knitr::opts_chunk$set(echo = TRUE, comment=NA, cache = TRUE)
options(tibble.width = Inf) # show all columns in output
```

# Contents

- [Introduction](#intro)

- [Getting started](#start)

- [Preprocessing](#preprocessing)

- [Reverse scoring survey items](#reverse)

- [Calculating survey scores](#score)

- [Calculating Cronbach’s alpha](#cronbach)

- [Comparing baseline scores between conditions (one-way ANOVA)](#baseline)

- [Comparing scores before and after an intervention (within-between ANOVA)](#prepost)

<a name="intro"></a>

# Before you start ...

This worksheet assumes you are familiar with the techniques described in the [preprocssing](preproc.html) worksheet. If you're getting stuck, then do that and return here.

# Introduction

A wide range of psychological constructs are measured using surveys. A survey is a set of questions designed to measure a specific construct, for example self-esteem. Answers to survey questions are often Likert scales. These allow a participant to express how much they agree or disagree with a particular statement e.g. 0=Not at all, 1=A little, 2=Somewhat, 3=A lot, 4=Extremely. A participant's answers are used to calculate a score which measures the construct. The questions themsleves are carefully chosen, often using a method called factor analysis. This ensures that the scale is valid and relible. A scale is valid if it is a true measure of the construct, in this example it accurately reflects levels of self-esteem, rather than something else. A scale is reliable if it gives consistent results, i.e. it would produce similar scores for a person who completed the scale at different times, or for two people who are similar for the construct which the scale measures.

In this worksheet, we'll cover some common techniques which you are likely to use when processing survey data. We'll be using real data from two different surveys. The DASS-21 is a 21-item scale for measuring depression, anxiety and stress. The State Self-Esteem Scale (SSES) is a 20-item survey used to measure short-lived (state) changes in self-esteem.

<a name="start"></a>

# Getting started

Create a new R project and upload the files `dass21.csv` and `state-self-esteem.sav`, which you will find in the git repository we used [previously](preproc.html#load).

FIXME <span style="color: red;">Add data sets to rminr-data</span>

```{r init-load, message=FALSE}
## Clear the environment
rm(list = ls())
library(tidyverse)
```

<a name="preprocessing"></a>

# Preprocessing

Survey data can be collected using [JISC](https://www.jisc.ac.uk/), [Gorilla Survey](https://gorilla.sc/), [OpenSesame](https://osdoc.cogsci.nl/), [The Experiment Factory](https://expfactory.github.io/experiments/), [Qualtrics](https://www.qualtrics.com/) and many other software packages.

Most software will allow you to save the survey data as a CSV file. The precise structure of the data varies between packages, so you are likely to have to start by preprocessing your data. The preprocessing tasks described in this worksheet should be useful regardless of the software you used to collect your survey data, although they might need slight modifications depending on the data you start with. The programming techniques described build on those covered in the [preprocssing worksheet](preproc.html).

## Loading data

We'll start by preprocessing the DASS-21 data, which is a wide format (one row per participant) CSV file.

```{r pre-process-dass}
dass21_raw <- read_csv("dass21.csv") %>%
  select(partID, Age:DASS21)
```

**Explanation of command** - We read the CSV file using `read.csv` and pipe the data into a `select` command, which picks just the columns we want, saving the results in `dass21_raw`. In the `select`, we include the participant ID using `partID`. To avoid having to type out long lists of column names, `select` also allows you to specify ranges of columns which are consecutive in a data frame by specifying the first and last column (left to right), separated by a `:`. In this case we use `Age:DASS21` to select all columns between `Age` and `DASS21`.

## Handling missing data

If participants don't complete a survey, you will want to exclude their data from your analyses. If we look at a section of the DASS-21 data, we can see some that data is missing for some participats.

```{r missing, R.options = list(width = 1000)}
# FIXME: this doesn't make the output wide and scrolly
slice(dass21_raw, 73:76)
```

The first thing to notice is that we only have the columns that we selected in the commands above. Participants 108, and 109 (rows 3 and 4) have numbers in all columns, indicating that their data is complete. However, participants 106 and 107 have cells containing the value `NA`, which means these cells in the CSV file were empty. For participant 106, all cells are `NA` (perhaps they dropped out of the study), and for participant 107, all of the DASS-21 cells are `NA` (perhaps they skipped this survey).

We can exclude any rows with missing data as follows:

```{r exclude-missing}
dass21 <- dass21_raw %>% drop_na()
```

**Explanation of command** - We pipe the raw data into the `drop_na()` function (part of the `tidyverse` package). This drops any rows with a column containing `NA`. This code would also exclude participants who only partially complete a survey.

## Tidying a data frame

In addition to removing columns which aren't required in your analysis, there are some other preprocessing tasks which you often want to apply to survey data before running any analyses. 
We'll demonstrate these using SSES data. We start by loading the data:

```{r read-sses}
library(foreign)
sses <- read.spss(paste0('state-self-esteem.sav'), to.data.frame=TRUE)
```

**Explanation of command** - The `.sav` file extension indicates that the SSES data was saved from SPSS. The `foreign` package allows R to read SPSS files into a data frame. We load the package, and then use `read.spss()` to read the data and store it in `sses`.
 
The data comes from from an experiment in which self-esteem was measured before and after participants completed one of two mental imagery conditions, or a control condition. For the next steps in our analysis it will be useful to divide the data into two data frames, one for the pre-intervention SSES, the other for the post-intervention SSES. We can do that in a single pipeline.

```{r preprocess-sses-pre}
sses_pre_raw  <- sses %>% select(1, 5:25) %>%
  set_names(~ str_to_lower(.) %>% str_replace_all("pre_sse_", "q")) %>%
  mutate(subj = factor(partid), condition = factor(condition), time = factor('pre')) %>%
  select(subj, condition, time, q1:q20)
```

**Explanation of pipeline commands:**

`sses_pre_raw  <- sses %>% select(1, 5:25)` - We save the output of the pipeline in `sses_pre_raw`. The first step pipes the full dataset, `sses` into a `select` which keeps column 1, and columns 5:25. Column 1 is the participant id, columns 5:24 are the SSES scores, and column 25 is the participant's condition.

`set_names(~ str_to_lower(.) %>% str_replace_all("pre_sse_", "q"))` - Next, we use `set_names()` to rename our columns. The `~` is a way of telling `set_names()` to apply a function to the column name. The remainder of the command is the function itself. This is a mini-pipeline which tidies up the column name. The command `str_to_lower(.)` makes the column name lowercase. The command `str_replace_all("pre_sse_", "q"))` replaces columns with the prefix `pre_sse_` with the prefix `q`. All our columns are now lowercase, and the SSES questions are named `q1:q20`.

`mutate(subj = factor(partid), condition = factor(condition), time = factor('pre'))` - Next, we use `mutate` to add and modify some columns. The argument `subj = factor(partid)` creates a new column named `subj` (which is a bit clearer than `partid`) by copying the `partid` column and making it a factor. The argument `condition = factor(condition)` makes the `condition` column a factor. The argument `time = factor('pre')` creates a new factor called `time` and sets all values to `pre`.

`select(subj, condition, time, q1:q20)` - Finally, we use `select` to put the columns into a convenient order for viewing.

## Recode factor levels

Software for running experiments may use numbers to represent different levels of a factor. It's often clearer if these are converted to strings which describe the factor. In this experiment, participants in condition 1 visualised a negative mental image of themself, participants in condition 2 visualised a negative mental image of someone else, and condition 0 was a control condition, in which participants did a card sorting task and did not think of any images.

```{r}
sses_pre_raw$condition <- recode_factor(sses_pre_raw$condition, `0` = 'control',
                                        `1` = 'self', `2` = 'other')

```

**Explanation of command:** We use `recode_factor()` to rename the levels of the experimental condition (`sses_pre_raw$condition`). The current factor level name goes on the left hand side of the `=`, the new name goes on the right hand side. Notice that the numbers need to be in backticks. The renamed factor levels are reassigned to the same column `sses_pre_raw$condition`.

Our data frame now has intuitive column and factor names:

```{r, R.options = list(width = 100)}
sses_pre_raw %>% head(3)
```

We use a similar pipeline to create a tidy data frame (`sses_post_raw`) containing the post-intervention SSES data.

```{r preprocess-sses-post}
sses_post_raw <- sses %>% select(1, 25:45) %>%
  set_names(~ str_to_lower(.) %>% str_replace_all("post_sse_", "q")) %>%
  mutate(subj = factor(partid), condition = factor(condition), time = factor('post')) %>%
  select(subj, condition, time, q1:q20)
sses_post_raw$condition <- recode_factor(sses_post_raw$condition, `0` = 'control',
                                        `1` = 'self', `2` = 'other')

```

**Explanation of command:** This is indentical to the previous pipeline, except that the post-intervention SSES data are in columns `26:45`, these columns have the prefix `post_sse_` rather than `pre_sse_`, and we use the value `post` in our `time` factor.

```{r, R.options = list(width = 100)}
sses_post_raw %>% head(3)
```

<a name="reverse"></a>

# Reverse score survey

The SSES consists of 20 questions, each of which is scored from 0 (Not at all) to 4 (Extremely). Question 1 reads `I feel confident about my abilities`, so a higher score indicates higher self-esteem. Many surveys have questions which are reverse scored, for example to encourage participants to read each question carefully. A number of questions on the SSES are reverse scored. For example, question 1 reads `I am worried about whether I am regarded as a success or failure`, so in this case a higher score indcates lower self-esteem. Before totalling the SSES, we need to reverse the reverse scored items, so that a higher number means higher self-esteem for all scores.

We can do this in R using a function:

```{r reverse-score-survey}
# Reverse score survey items
# @param scores raw scores data frame
# @param reverse character vector of columns to be reverse scored
# @param max integer value of maximum score
reverse_score_survey <- function(scores, reverse, max) {
  reverse_score <- function(score) { max - score } # for scores starting at 1, max + 1 - score
  scores %>% mutate_at(reverse, reverse_score)
}
```

**Explanation of commands:**

We name our function `reverse_score_survey` and indicate that it requires three arguments: `scores` is a data frame containing our raw survey responses, i.e. with some items reverse scored, `reverse` is a character vector containing the column names of the scores that are reverse scored, and `max` is the maximum score available for an item on the Likert scale.

Inside this function, we define another function called `reverse_score` which takes a `score` argument, and reverses it using the calculation `max - score`. For example, `reverse_score(4)`, would return the value `0` (`4 - 4`).  If your survey scores began at 1, you could adjust the calculation to `max + 1 - score`.

The final line in `reverse_score_survey` pipes our raw scores into `mutate_at(reverse, reverse_score)`. The `mutate_at()` function applies a function to a subset of columns in a data frame. The first argument `reverse` is the list of column names to be reversed. The second argument `reverse_score` is the name of the function we wrote to reverse the score.

When we call `reverse_score_survey`, the result will be a data frame with all scores adjusted to be from 0 to `max`.

Now we can use `reverse_score_survey` to reverse score our pre and post intervention SSES scores:

```{r reverse-pre}
reverse_questions <- c('q2', 'q4', 'q5', 'q7', 'q8', 'q10', 'q13', 'q15', 'q16', 'q17', 'q18',
                       'q19', 'q20')
sses_pre  <- reverse_score_survey(sses_pre_raw, reverse_questions, 4)
sses_post <- reverse_score_survey(sses_post_raw, reverse_questions, 4)
```

**Explanation of commands:**

We set `reverse_questions` to be a vector of the column names of the SSES items that are reverse scored.

Next we call the function `reverse_score_survey(sses_pre_raw, reverse_questions, 4)`. When the function is run, `sses_pre_raw` is assigned to the `scores` argument, `reverse_questions` to the `reverse` argument, and `4` to the `max` argument. The resulting data frame (higher score meaning higher self-esteem for all items) is assigned to `sses_pre`.

Similarly, we reverse score the post-intervention surveys and assign the result to `sses_post`.

<a name="score"></a>

# Calculate a total score for pre and post

```{r score}
sses_pre <- sses_pre %>% mutate(total = rowSums(.[4:23]))
sses_pre %>%
  group_by(condition) %>%
  summarise(mean = mean(total), sd = sd(total))

sses_post <- sses_post %>% mutate(total = rowSums(.[4:23]))
sses_post %>%
  group_by(condition) %>%
  summarise(mean = mean(total), sd = sd(total))
```

## Calculate subscale scores

using DASS-21

DASS-21 came from the tech office with subscale scores already calculated.

<a name="cronbach"></a>

# Calculate Cronbach’s alpha

Cronbach's alpha is a measure of the reliability of a scale.

```{r cronbach}
library(psy)

#TODO overall alpha

sses_cronbach <- function(scores) {
  cronbach <- cronbach(select(scores,q1:q20))
  data.frame(cronbach$alpha)
}

sses_pre_cronbach <- sses_pre %>%
  group_by(condition) %>%
  group_modify(~ sses_cronbach(.x))
sses_pre_cronbach

sses_post_cronbach <- sses_post %>%
  group_by(condition) %>%
  group_modify(~ sses_cronbach(.x))
sses_post_cronbach
```

<a name="baseline"></a>

# Compare baseline SSES scores between conditions

Now that our we have calculated a total SSES score for each participant, we would like to check that there were no major differences between groups before our intervention. This should be the case if we successfully randomised participants to groups, but if there are baseline differences we would need to account for these when analysing post-intervention scores. We can use a [within-subjects ANOVA](anova1.html#anovaWS) to compare the baseline SSES scores in our three groups.

```{r baseline}
library(BayesFactor, quietly = TRUE)
# FIXME: in base::try(expression, silent = silent) : not enough observations
bf <- anovaBF(formula = total ~ condition + subj, data = sses_pre, whichRandom = 'subj')
bf <- anovaBF(formula = total ~ condition, data = sses_pre)
bf
```

The Bayes factor of `0.68` is greater than the conventional `0.33` which would satisfy us that there were no differences between the groups. If we generate some descriptive statistics, we can see that the mean and standard deviation are slightly lower in the `other` group. We'll address this issue in the next section.

```{r baseline-descriptives}
sses_pre %>% group_by(condition) %>% summarise(mean = mean(total), sd = sd(total))
```

<a name="prepost"></a>

# Compare pre and post intervention SSES scores between conditions

The main question we're interest in answering is whether our two imagery interventions 
(visualising a negative mental image of oneself, or someone else) affected self esteem, relative to a control condition.  We can use a [factorial ANOVA](anova3.html#bfact) to compare SSES scores before and after the three interventions. In this design, `condition` is a between-subjects variable, and `time` (pre and post intervention) is a repeated measure.

First we combine the pre and post data frames:

```{r prepost}
sses_pre_post <- bind_rows(sses_pre, sses_post) %>%
  mutate(time = factor(time))
```

Then we run our anova, including `subj` as a random factor:

```{r mixed-anova}
bf <- anovaBF(formula = total ~ time*condition + subj,
              data = sses_pre_post, whichRandom = 'subj')

```

Our Bayes factors indicate that there is a main effect of `condition`,

```{r condition}
bf[1]
```

no main effect of `time`,

```{r time}
bf[2]
```

and a `condition*time` interaction

```{r condition*time}
bf[4] / bf[3]
```

Given the interaction, we would probably want to carry out [pairwise comparisons](anova1.html#pairs) to compare the imagery conditions against the control condition, and against each other. Finally, to address the small difference in baseline scores, we could run the same ANOVA on the _difference_ between the pre and post scores, or we could include the baseline score as a covariate in an ANCOVA.  These techniques are outside the scope of this worksheet.

# References

Heatherton, T. F., & Polivy, J. (1991). Development and validation of a scale for measuring state self-esteem. _Journal of Personality and Social Psychology, 60(6)_, 895.

Osman, A., Wong, J. L., Bagge, C. L., Freedenthal, S., Gutierrez, P. M., & Lozano, G. (2012). The Depression Anxiety Stress Scales—21 (DASS-21): Further Examination of Dimensions, Scale Reliability, and Correlates. _Journal of Clinical Psychology, 68(12)_, 1322–1338. https://doi.org/10.1002/jclp.21908

___

This material is distributed under a [Creative Commons](https://creativecommons.org/) licence. CC-BY-SA 4.0. 

